---
layout:     post
title:      JVM - 垃圾回收
date:       2021-08-24 13:51:11 +0800
postId:     2021-08-24-13-51-11
categories: [JVM]
keywords:   [Java,JVM]
---

经过半个世纪的发展，今天的内存动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”
时代，但当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，
就必须对这些“自动化”的技术实施必要的监控和调节。

Java 内存运行时区域的各个部分中，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程
而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存
基本上是在类结构确定下来时就已知的(尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的
讨论里，大体上可以认为是编译期可知的)，因此这几个区域的内存分配和回收都具备确定性，在这几个区域
内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。

而 Java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，
一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会
创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存
该如何管理，本文后续讨论中的“内存”分配与回收也仅仅特指这一部分内存。

## 对象已死
垃圾收集器工作的时候，必须确定，哪些对象是可以被回收的。判断对象是否已死有如下几种方式：
* 引用计数法
* 可达性分析

### 引用计数算法
很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，
计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

客观地说，引用计数算法(Reference Counting)虽然占用了一些额外的内存空间来进行计数，但它的
原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。但是，在 Java 领域，至少主流的 
Java 虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况
要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环
引用的问题。

### 可达性分析
当前主流的商用程序语言(Java、C#，上溯至前面提到的古老的 Lisp)的内存管理子系统，都是通过可达
性分析(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称
为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路
径称为“引用链”(Reference Chain)，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论
的话来说就是 从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

如图 3-1 所示，对象 object 5、object 6、object 7 虽然互有关联，但是它们到 GC Roots 是
不可达的，因此它们将会被判定为可回收的对象。

![可达性分析]({{ site.baseurl }}/image/post/2021/08/24/01/gc-roots.png)

问题：
1. 哪些对象可以作为根对象呢？
2. 如果在可达性分析算法中被判定不可达对象，是不是一定会被回收？

## 垃圾收集算法
垃圾收集算法的实现涉及大量的程序细节，且各个平台的虚拟机操作内存的方法都有差异，在本
节中我们暂不过多讨论算法实现，只重点介绍分代收集理论和几种算法思想及其发展过程。

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”(Generational Collection)的理论
进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个
分代假说之上:

* 弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。
* 强分代假说(Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则:收集器应该将Java堆划分出不同的
区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。
显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在
一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收
到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率
来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为`新生代`(Young 
Generation)和`老年代`(Old Generation)两个区域。顾名思义，在新生代中，每次垃圾收集时都
发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代
所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有
对5 象来确保可达性分析结果的正确性，反过来也是一样。为了解决这个问题，就需要对分代收集理论添加第
三条经验法则:

* 跨代引用假说(Intergenerational Reference Hypothesis)：跨代引用相对于同代引用来说仅占极少数。

这其实是可根据前两条假说逻辑推理得出的隐含推论:存在互相引用关系的两个对象，是应该倾向于同时生存
或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得
新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

### 标记-清除算法
最早出现也是最基础的垃圾收集算法是“标记-清除”(M ark-Sweep)算法，在1960年由Lisp之父 John 
McCarthy所提出。如它的名字一样，算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，
在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

缺点：
* 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;
* 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。








开始写作吧
```
![image-alter]({{ site.baseurl }}/image/post/2021/08/24/01/xxx.jpg)
```

## 参考资料
* [JVM - 垃圾回收]({% post_url java/jvm/content/2021-08-24-01-jvm-gc %})
* [JVM - 引用类型]({% post_url java/jvm/content/2021-08-24-02-jvm-reference-type %})
* [深入理解Java虚拟机（第3版）](https://book.douban.com/subject/34907497/)
