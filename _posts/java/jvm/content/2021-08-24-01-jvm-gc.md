---
layout:     post
title:      JVM - 垃圾回收
date:       2021-08-24 13:51:11 +0800
postId:     2021-08-24-13-51-11
categories: [JVM]
keywords:   [Java,JVM]
---

经过半个世纪的发展，今天的内存动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”
时代，那为什么我们还要去了解垃圾收集和内存分配?答案很简单:当需要排查各种内存溢出、内存泄漏
问题时，当垃圾收集成为系统达到更高并发量 的瓶颈时，我们就必须对这些“自动化”的技术实施必要的
监控和调节。

Java 内存运行时区域的各个部分中，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随
线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配
多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由即时编译器进行一些优化，但在基于
概念模型的讨论里，大体上可以认 为是编译期可知的)，因此这几个区域的内存分配和回收都具备确定性，
在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。

而 Java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，
一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会
创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存
该如何管理，本文后续讨论中的“内存”分配与回收也仅仅特指这一部分内存。

## 对象已死
垃圾收集器工作的时候，必须确定，哪些对象是可以被回收的。判断对象是否已死有如下几种方式：
* 引用计数法
* 可达性分析

### 引用计数算法
很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，
计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

客观地说，引用计数算法(Reference Counting)虽然占用了一些额外的内存空间来进行计数，但它的
原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。但是，在 Java 领域，至少主流的 
Java 虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况
要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环
引用的问题。

### 可达性分析
当前主流的商用程序语言(Java、C#，上溯至前面提到的古老的 Lisp)的内存管理子系统，都是通过可达
性分析(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称
为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路
径称为“引用链”(Reference Chain)，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论
的话来说就是 从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

如图 3-1 所示，对象 object 5、object 6、object 7 虽然互有关联，但是它们到 GC Roots 是
不可达的，因此它们将会被判定为可回收的对象。

![可达性分析]({{ site.baseurl }}/image/post/2021/08/24/01/gc-roots.png)




开始写作吧
```
![image-alter]({{ site.baseurl }}/image/post/2021/08/24/01/xxx.jpg)
```

## 参考资料
* [JVM - 垃圾回收]({% post_url java/jvm/content/2021-08-24-01-jvm-gc %})
* [JVM - 引用类型]({% post_url java/jvm/content/2021-08-24-02-jvm-reference-type %})
* [深入理解Java虚拟机（第3版）](https://book.douban.com/subject/34907497/)
