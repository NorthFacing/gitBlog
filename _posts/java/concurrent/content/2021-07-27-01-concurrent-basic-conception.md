---
layout:     post
title:      Java并发 - 基本概念
date:       2021-07-27 22:10:44 +0800
postId:     2021-07-27-22-10-45
categories: [concurrent]
keywords:   [Java,concurrent]
---

## 基本的名词解释

### 并发与并行
并发和并行是非常相似的概念。并发是在单个处理器上采用单核执行多个任务即为并发，在这种情况下，
操作系统的任务调度程序会很快从一个任务切换到另一个任务，因此看起来所有任务都是同时运行的。
同一时间在不同的计算机、处理器或处理器核心上同时运行多个任务，就是所谓的“并行”。

### 同步
将 `同步` 定义为一种协调两个或更多任务以获得预期结果的机制。同步方式有两种：
* 控制同步：当一个任务的开始依赖于另一个任务的结束时，第二个任务不能在第一个任务完成之前开始
* 数据访问同步：当两个或更多任务访问共享变量时，在任意时间里，只有一个任务可以访问该变量。

### 临界段
与同步密切相关的一个概念是临界段。临界段是一段代码，由于它可以访问共享资源，因此在任何给定时间
内，只能够被一个任务执行。

### 互斥
互斥是用来保证 `临界段` 这一要求的机制，而且可以采用不同的方式来实现。

### 粒度
同步可以帮助你在完成并发任务的同时避免一些错误，但是它也为 你的算法引入了一些开销。这就涉及并发
算法的粒度。如果算法有着粗粒度(低互通信的大型任务)，同步方 面的开销就会较低。如果算法有着细粒度
(高互通信的小型 任务)，同步方面的开销就会很高，而且该算法的吞吐量可能不会很好。

### 不可变对象
不可变对象是一种非常特殊的对象。在其初始化后，不能修改其可视状态(其属性值)。如果想修改一个
不可变对象，那么你就必须创建一个新的对象。不可变对象的主要优点在于它是线程安全的。

### 原子操作和原子变量

#### 原子操作
原子操作是一种发生在瞬间的操作。在并发应用程序中，可以通过一个临界段来实现原子操作，以便对整个
操作采用同步机制。

#### 原子变量
原子变量是一种通过原子操作来设置和获取其值的变量。可以使用某种同步机制来实现一个原子变量，或者
也可以使用 CAS 以无锁方式来实现一个原子变量，而这种方式并不需要任何同步机制。

## 通信方式
任务可以通过两种不同的方法来相互通信：共享内存 & 消息传递。

### 共享内存
同一台计算机上 运行多任务的情况时，任务在读取和写入值的时候使用相同的内存区域。为了避免出现
问题，对该共享内存的访问必须在一个由同步机制保护的临界段内完成。

### 消息传递
在不同计算机上运行多任务的情形时，当一个任务需要与另一个任务通信时，它会发送一个遵循预定义协议
的消息。如果发送方保持阻塞并等待响应，那么该通信就是同步的；如果发送方在发送消息后继续执行自己
的流程，那么该通信就是异步的。

### 线程安全
如果共享数据的所有用户都受 到同步机制的保护，那么代码(或方法、对象)就是线程安全的。

## 同步机制
并发系统中有不同的同步机制。从理论角度来看，最流行的机制如下：信号量 & 监视器。

### 信号量
信号量(semaphore)，一种用于控制对一个或多个单位资源进行访问的机制。它有一个用于存放可用资源
数量的变量，并且可以采用两种原子操作来管理该变量的值。互斥(mutex，mutual exclusion 的简写
形式)是一种特殊类型的信号量，它只能取两个值(即资源空闲和资源忙)， 而且只有将互斥设置为忙的那个
进程才可以释放它。互斥可以通过保护临界段来帮助你避免出现竞争条件。

### 监视器
监视器是一种在共享资源之上实现互斥的机制。它有一个互斥、一个条件变量、两种操作(等待条件和通报
条件)。一旦你通报了该条件，在等待它的任务中只有一个会继续执行。

## 并发应用程序中可能出现的问题
编写并发应用程序并不是一件容易的工作。如果不能正确使用同步机制，应用程序中的任务就会出现各种
问题。

### 数据竞争/竞争条件
如果有两个或者多个任务在临界段之外对一个共享变量进行写入操作，也就是说没有使用任何同步机制，
那么应用程序可能存在数据竞争(也叫作竞争条件)。

### 死锁
当两个(或多个)任务正在等待必须由另一线程释放的某个共享资源，而该线程又正在等待必须由前述任务
之一释放的另一共享资源时，并发应用程序就出现了死锁。当系统中同时出现如下四种条件时，就会导致
这种情形。我们将其称为 Coffman 条件。

* 互斥：死锁中涉及的资源必须是不可共享的。一次只有一个任务可以使用该资源。
* 占有并等待条件：一个任务在占有某一互斥的资源时又请求另一互斥的资源。当它在等待时，不会释放任何资源。
* 不可剥夺：资源只能被那些持有它们的任务释放。
* 循环等待：任务 1 正等待任务 2 所占有的资源， 而任务 2 又正在等待任务 3 所占有的资源，以此类推，最终任务 n 又在等待由任务 1 所占有的资源，这样就出现了循环等待。

### 活锁
如果系统中有两个任务，它们总是因对方的行为而改变自己的状态，那么就出现了活锁。最终结果是它们
陷入了状态变更的循环而无法继续向下执行。

### 资源不足
当某个任务在系统中无法获取维持其继续执行所需的资源时，就会出现资源不足。当有多个任务在等待某一
资源且该资源被释放时，系统需要选择下一个可以使用该资源的任务。如果你的系统中没有设计良好的算法，
那么系统中有些线程很可能要为获取该资源而等待很长时间。

### 优先权反转
当一个低优先权的任务持有了一个高优先级任务所需的资源时，就会发生优先权反转。这样的话，低优先权
的任务就会在高优先权的任务之前执行。

## 参考资料

* [Java并发 - 基本概念]({% post_url java/concurrent/content/2021-07-27-01-concurrent-basic-conception %})
* [7.4' - 精通Java并发编程（第2版）](https://book.douban.com/subject/30327401/)
