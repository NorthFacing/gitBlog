
## 进程、线程和协程之间的区别

进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程
至少有一个线程。进程在执行过程中有独立的内存单元，而多个线程共享内存
资源，减少切换次数，从而效率更高。线程是进程的一个实体，是CPU调度和
分派的 基本单位，是比程序更小的能独立运行的基本单位，同一个进程中多个
线程之间可以并发执行。

## 守护线程

在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 
用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；
只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是
GC (垃圾回收器)，它就是一个很称职的守护者。User和Daemon两者几乎没有
区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出
运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守
护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。

参考：http://blog.csdn.net/shimiso/article/details/8964414

## 创建线程

* 继承Thread类
* 实现Runnable接口

Runnable可以方便的进行资源共享，thread并不能，thread实现了runnable接口

更多的是使用Runanble接口，因为Java不支持多继承，而且继承整个Thread类的
开销过大。

## run(）和 statr()的区别
run()方法:
在本线程内调用该Runnable对象的run()方法，可以重复多次调用；
run()和其他方法的调用没任何不同,main方法按顺序执行了它,并打印出最后一句

start()方法:
start()方法重新创建了一个线程,在main方法执行结束后,由于start()方法创建的线程没有运行结束,
因此主线程未能退出,直到线程thread也执行完毕.这里要注意,默认创建的线程是用户线程(非守护线程)



## 线程阻塞

方法|说明
---|---
sleep()| 允许指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，指定的时间一过，线程重新进入可执行状态。
yield()|使得线程防窃当前分得的CPU时间，但不进入阻塞状态，即线程仍然处于可执行状态，随时可能再次分得CPU时间。调用yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。
（已废弃）suspend()和resume()|两个方法配套使用，suspend() 使得线程进入阻塞状态，并且不会自动恢复，直到使用resume()方法，才能使得线程进入可执行状态
wait()和notify()|两个方法配套使用，wait()使得线程进入阻塞状态，他有两种形式，一种允许执行以毫秒为单位的一段时间作为参数，另一种没有参数。前者对应的notify()被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的notify()被调用
join()|join()方法使当前线程停下来等待，直至另一个调用join方法的线程终止。值得注意的是，线程的在被激活后不一定马上就运行，而是进入到可运行线程的队列中。但是join()可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException。

乍看，后两组方法没有区别，但事实上他们是不同的。

suspend & resume | wait & notify
---|---
suspend 是Thread类的方法 | wait 是 Object 类的方法
阻塞时都不会释放占用的锁（如果占用了的话）| 这一对方法阻塞时释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并 且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等 到获得锁后才真正可执行）。这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在 synchronized 方法或块中当前线程才占有锁，才有锁可以释放。

参考：http://blog.csdn.net/apache012/article/details/9320805


## 线程局部变量

ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。
ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副
本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来
性能消耗，也减少了线程并发控制的复杂度。
 
ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的
使用比synchronized要简单得多。
 
ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal
与synchronized有本质的区别。synchronized是利用锁的机制，使变量
或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程
都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对
象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相
反，它用于在多个线程间通信时能够获得数据共享。
 
Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。
 
当然ThreadLocal并不能替代synchronized,它们处理不同的问题域。
Synchronized用于实现同步机制，比ThreadLocal更加复杂。

## 线程安全相关

http://www.tuicool.com/articles/zuui6z

## 乐观锁 & 悲观锁

* 乐观锁  
增加一个版本号标记，当进行数据修改的时候，首先验证版本号是否
被修改，如果没有被修改则进行数据更新，如果已经更改，则说明其
他线程已经进行了更改，更新失败，之后采取对应的策略进行后续的
处理，比如再次进行数据的更新请求等。优点是防止并发导致的数据
错误，但是在并发量大的时候，因为重复请求，会增加服务器的负担。

使用场景：java cas ,redis watch ，数据库记录修改加版本号等

* 悲观锁  
当有请求过来，就

## 死锁 & 活锁

* 死锁  
是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于
彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法
推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远
在互相等待的进程称为死锁进程。

* 活锁  
活锁指的是任务或者执行者没有被阻塞，
由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，
导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，
处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁
的实体表现为等待；活锁有可能自行解开，死锁则不能。

## 多线程开发良好实践
* 给线程命名
* 最小化同步范围
* 优先使用volatile
* 尽可能使用更高层次的并发工具而非使用wait和notify来实现线程通信，如BlockingQueue和Semeaphore
* 优先使用并发容器而非同步容器
* 考虑使用线程池

## 同步容器与并发容器有什么区别？

同步容器有Vector、Hashtable，并发容器有ConcurrentHashMap

何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，
如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector，
Hashtable，以及Collections.synchronizedSet，synchronizedList
等方法返回的容器。

并发容器：并发容器是针对多个线程并发访问设计的，在jdk5.0引入了
concurrent包，其中提供了很多并发容器，如ConcurrentHashMap，
CopyOnWriteArrayList等。并发容器使用了与同步容器完全不同的加锁
策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了
一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意
数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也
可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，
所以它可以在并发环境下实现更高的吞吐量。

## Volatile 关键字 [ˈvɑ:lətl]
Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和
volatile 关键字机制。

synchronized
同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized
和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用synchronized 修饰
的方法 或者 代码块。

volatile
用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。
volatile很容易被误用，用来进行原子性操作。


## 可见性 && 原子性

可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个
线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可
见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他
线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，
但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变
量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个
操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是
a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，
需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，
那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读
API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。　　


https://www.ibm.com/developerworks/cn/java/j-jtp06197.html

## DelayQueue [kju]


## join、CountDownLatch、CyclicBarrier 和 Semaphore
http://developer.51cto.com/art/201403/432095.htm

比如面试官可能会先问你，如果想实现所有的线程一起等待某个事件的发生，当某个事件发生时，所有线程一起开始往下执行的话，有什么好的办法吗？
这个时候你可能会说可以用栅栏（Java的并发包中的CyclicBarrier），那么面试官就会继续问你，你知道它的实现原理吗？
如果你继续回答的话，面试官可能会继续问你，你还知道其它的实现方式吗？
如果你还能说出很多种实现方式的话，那么继续问你，你觉得这些方式里哪个方式更好？
如果你说出来某一个方式比较好的话，面试官依然可以继续问你，那如果让你来写的话，你觉得还有比它更好的实现方式吗？
如果你这个时候依然可以说出来你自己更好的实现方式，那么面试官肯定还会揪着这个继续问你。

CountDownLatch 的作用和 Thread.join() 方法类似，可用于一组线程和另外一组线程的
协作。例如，主线程在做一项工作之前需要一系列的准备工作，只有这些准备工作都完成，主
线程才能继续它的工作。这些准备工作彼此独立，所以可以并发执行以提高速度。在这个场景
下就可以使用 CountDownLatch 协调线程之间的调度了。在直接创建线程的年代（Java 5.0
之前），我们可以使用 Thread.join()。在 JUC 出现后，因为线程池中的线程不能直接被
引用，所以就必须使用 CountDownLatch 了。



CountDownLatch：
一个线程等待一组线程执行完毕之后，再执行

CyclicBarrier：
一组线程等待到同一个时间点之后一起执行。



# ConcurrentHashMap

https://www.google.com/#newwindow=1&q=JDK8+ConcurrentHashMap+%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&*
http://www.cnblogs.com/huaizuo/p/5413069.html
http://blog.csdn.net/u010723709/article/details/48007881


* 非静态方法:
给对象加锁(可以理解为给这个对象的内存上锁,注意 只是这块内存,其他同类对象都会有各自的内存锁),这时候
在其他一个以上线程中执行该对象的这个同步方法(注意:是该对象)就会产生互斥

* 静态方法:
相当于在类上加锁(*.class 位于代码区,静态方法位于静态区域,这个类产生的对象公用这个静态方法,所以这块
内存，N个对象来竞争), 这时候,只要是这个类产生的对象,在调用这个静态方法时都会产生互斥

# 静态方法内部声明局部变量是线程安全的吗？



# 参考
* [Java并发编程那些事儿](https://hellofrank.github.io/2020/06/22/Java并发编程那些事儿-一-——任务与线程/)
