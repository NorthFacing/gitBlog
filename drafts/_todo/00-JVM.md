
# JVM 相关
Survivor [sərˈvaɪvə(r)]




## 7、Java中的四种引用类型
* 强引用  
    如果一个对象是强引用，那么它就不会被垃圾回收器回收。内存不足时，抛出OutOfMemoryError错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显示的将其设置为null，这样，JVM就可以在合适的时候进行垃圾回收。
* 软引用  
    如果内存空间足够，软引用就会一直存在；只有当内存不足时，才会被垃圾回收器回收。
* 弱引用  
    弱引用对象的声明周期更短，无论当前内存是否足够，只要被垃圾回收期检测到就会被回收。不过垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。
* 虚引用  
    顾名思义，形同虚设，相当于没有引用，任何时候都可以被垃圾回收器回收。

## 9、编译器常量
公共静态不可变变量也就是我们所以说的编译器常量，这里的public是可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且在运行时不会被更改。唯一需要注意的地方在于，如果引用了第三方包，替换包的时候如果值有变化，就要重新编译程序，不然程序中的值还是原来的包内的常量的值。

## 10、如何判断一个对象是否应该被垃圾回收

* 引用计数
* 对象可达性分析

当前虚拟机大部分使用对象可达性分析来判断。

## 11、垃圾回收算法

* 标记-清除  
    会暂停当前程序的运行；会产生大量的内存碎片
* 标记-复制  
    也会暂停当前程序；可用空间缩小为原来的一般，空间利用率低
* 标记-整理  
    也会暂停当前程序；非实时性的回收
* 分代回收  
    - 新生代  
        每次垃圾回收都有大量对象死去，使用标记-复制算法，另外因为死去的对象大概占比98%，所以不需要按照1:1来分配内存，而是划分为一块较大的Eden和两块较小的Survivor区域，大小为8:1。每次新生代可用区域为Eden加上其中一块Survivor区域，共90%的内存空间，这样只有10%内存被闲置。当存活的对象大于10%的内存空间，也就是Survivor内存空间不够用时，就将某些存活时间足够长的对象转移到老年代。
    - 老年代
        对于老年代来说，大部分对象都处于存活状态。如果一个大对象在老年代依然放不下，那就要在老年代使用标记-清除或者标记-整理算法来进行垃圾回收了。
    - 永久代

## 调用System.gc()会发生什么
通知GC开始工作，但是GC真正开始的时间不确定。

## 参数配置的几个常用指令

参数名称	| 含义 | 默认值	| 备注
---|---|---|---
-Xms | 初始堆大小 | 物理内存的1/64(<1GB) | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.
-Xmx | 最大堆大小 | 物理内存的1/4(<1GB) | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制
-Xmn | 年轻代大小(1.4or lator)  |  | 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. 增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8
-XX:NewSize | 设置年轻代大小(for 1.3/1.4)
-XX:MaxNewSize | 年轻代最大值(for 1.3/1.4)
-XX:PermSize | 设置持久代(perm gen)初始值	物理内存的1/64
-XX:MaxPermSize | 设置持久代最大值	物理内存的1/4
-Xss | 每个线程的堆栈大小 |  | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右。一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:"”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。

参考：
http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html

## 什么是 StackOverflow
一般出现在递归算法里，线程本地栈空间，因为压入的指针和参数过多导致溢出，一般JVM栈空间是1～2M。

## 栈空间分配过大会导致什么？


## OOM（OutOfMemory）异常遇到过吗

## 怎么检测死循环
但是解决思路是JPS + JSTACK查看是否有线程长期处于RUNNING状态？实在解决不了做个Dump吧。

JSTACK 常用方式方法？

## GC
面试官可以先问你什么时候一个对象会被GC？
接着继续问你为什么要在这种时候对象才会被GC？
接着继续问你GC策略都有哪些分类？
你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？
你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？
你如果选出来了，继续问你，为什么要选择这个策略？


## 类加载器
首先肯定是先问你Java的类加载器都有哪些？
回答了这些以后，可能会问你每个类加载器都加载哪些类？
说完以后，可能会问你这些类加载之间的父子关系是怎样的？
你在回答的时候可能会提到双亲委派模型，那么可以继续问你什么是双亲委派模型？
你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？
你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？


## 内存模型
首先肯定就是问你内存分为哪几部分，这些部分分别都存储哪些数据？
然后继续问你一个对象从创建到销毁都是怎么在这些部分里存活和转移的？
接着可能会问你，内存的哪些部分会参与GC的回收？
完事以后，可能还会问你Java的内存模型是怎么设计的？
你回答了以后，还会继续问你为什么要这么设计？
问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？
你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。
基本上Java语言本身以及语言稍微高级点的内容就是以上部分，如果你能把以上四部分了解的非常透彻，那基本上Java这部分就没啥问题了，因为光以上的内容就够你跟面试官聊很久了。你聊这些聊得久了，自然问你其它问题的时间就会短点。
你从LZ写这些问题的过程也应该能感受出来，很多时候，面试官都是顺着一条线一路问下去的，如果你觉得这条线你不熟悉的话，就要及时拐弯，引导面试官去问其它方面的问题。千万不要一直往下深入，直到自己跳不出来为止，那就尴了个尬了。


# 反射的类分配的内存是永久代吗？
反射出来的实例是堆中，但是反射出来的class信息有存储到永久代中吗？



## 其他
参考：https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java基础知识?id=jvm
* 对象引用存放在栈内存中
* 从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
* 类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存里

参考：http://xzoo.org/posts/java-classinstancevariable/




